import os
import json
import boto3
import tempfile
import subprocess
from pathlib import Path
from datetime import datetime
from github import Github, GithubException

s3_client = boto3.client('s3')
secrets_client = boto3.client('secretsmanager')

def lambda_handler(event, context):
    print(f"Deployer Lambda invoked with event: {json.dumps(event)}")

    scan_id = event.get('scan_id')
    repo_url = event.get('repo_url')
    base_branch = event.get('branch', 'main')
    bucket_name = event.get('s3_bucket')
    github_token_secret_name = event.get('github_token_secret_name')

    if not scan_id or not repo_url:
        return {'statusCode': 400, 'error': 'scan_id and repo_url are required'}

    try:
        if not github_token_secret_name:
            raise Exception("GitHub token secret name is required")
        if not bucket_name:
            raise Exception("S3 bucket name is required")

        github_token = get_github_token(github_token_secret_name)
        gh = Github(github_token)

        print(f"Retrieving full scan record for {scan_id}")
        scan_data = get_scan_result(bucket_name, scan_id)
        patch_plan = scan_data.get('patch_plan', [])

        approved_patch_plan = []
        for item in patch_plan:
            finding_id = item.get("finding_id")
            matching_finding = next(
                (f for f in scan_data.get("findings", []) if f["id"] == finding_id), None
            )
            if not matching_finding or matching_finding.get("approved"):
                approved_patch_plan.append(item)

        if not approved_patch_plan:
            return {
                'statusCode': 200,
                'scan_id': scan_id,
                'message': 'No approved patches found ‚Äî skipping deployment.',
                'fixes_applied': 0
            }

        patch_plan = approved_patch_plan

        if not patch_plan:
            return {
                'statusCode': 200,
                'scan_id': scan_id,
                'message': 'No patch plan found, skipping deployment.',
                'fixes_applied': 0
            }

        repo_full_name = extract_repo_name(repo_url)
        gh_repo = gh.get_repo(repo_full_name)
        new_branch_name = f"security-fixes/{scan_id}"

        print(f"Applying {len(patch_plan)} fixes to {repo_full_name}")

        with tempfile.TemporaryDirectory() as tmp_dir:
            repo_path = Path(tmp_dir) / 'repo'

            clone_cmd = [
                'git', 'clone',
                '--depth', '1',
                '--branch', base_branch,
                f'https://{github_token}@github.com/{repo_full_name}.git',
                str(repo_path)
            ]
            subprocess.run(clone_cmd, check=True, capture_output=True)

            subprocess.run(['git', 'config', 'user.name', 'awsdispatchprbot'], cwd=repo_path, check=True)
            subprocess.run(['git', 'config', 'user.email', 'awsdispatchprbot@users.noreply.github.com'], cwd=repo_path, check=True)
            subprocess.run(['git', 'checkout', '-b', new_branch_name], cwd=repo_path, check=True)

            fixes_applied = 0
            for remediation in patch_plan:
                try:
                    apply_fix(repo_path, remediation)
                    fixes_applied += 1
                except Exception as e:
                    print(f"Warning: Could not apply fix to {remediation['file']}: {str(e)}")
                    continue

            status_result = subprocess.run(
                ['git', 'status', '--porcelain'],
                cwd=repo_path,
                capture_output=True,
                text=True,
                check=True
            )

            if not status_result.stdout.strip():
                print("No changes detected after applying fixes.")
                return {
                    'statusCode': 200,
                    'scan_id': scan_id,
                    'message': 'No changes to commit',
                    'fixes_applied': 0
                }

            subprocess.run(['git', 'add', '-A'], cwd=repo_path, check=True)

            commit_message = f"""üîí Automated security fixes (Scan ID: {scan_id})

Applied {fixes_applied} AI-generated remediations.

Generated by AWS Dispatch Security Agent (Bedrock + Claude).
"""
            subprocess.run(['git', 'commit', '-m', commit_message], cwd=repo_path, check=True)
            subprocess.run(['git', 'push', 'origin', new_branch_name], cwd=repo_path, check=True)

        print("Creating pull request...")
        pr_title = f"ü§ñ Automated Security Fixes - Scan {scan_id}"
        pr_body = generate_pr_description(scan_data, scan_id)

        pr = gh_repo.create_pull(
            title=pr_title,
            body=pr_body,
            head=new_branch_name,
            base=base_branch
        )

        try:
            pr.add_to_labels('security', 'automated')
        except GithubException:
            print("Warning: Could not add labels (labels may not exist)")

        scan_data['status'] = 'completed'
        scan_data['stage'] = 'deployer'
        scan_data['timestamp'] = datetime.utcnow().isoformat()
        scan_data['deployment'] = {
            'pr_url': pr.html_url,
            'pr_number': pr.number,
            'branch': new_branch_name,
            'fixes_applied': fixes_applied
        }

        analysis = scan_data.get('analysis', {})
        analysis['summary'] = f"Deployed {fixes_applied} automated fixes via PR #{pr.number}"
        scan_data['analysis'] = analysis

        output_path = f"scan-results/{scan_id}/result.json"

        s3_client.put_object(
            Bucket=bucket_name,
            Key=output_path,
            Body=json.dumps(scan_data, indent=2),
            ContentType='application/json'
        )

        print(f"Final scan record updated in s3://{bucket_name}/{output_path}")

        return {
            'statusCode': 200,
            'scan_id': scan_id,
            'pr_url': pr.html_url,
            'pr_number': pr.number,
            'branch': new_branch_name,
            'fixes_applied': fixes_applied,
            'message': f"Created PR with {fixes_applied} security fixes"
        }

    except Exception as e:
        error_msg = f"Deployer error: {str(e)}"
        print(error_msg)
        import traceback
        traceback.print_exc()
        return {'statusCode': 500, 'error': error_msg}


def get_github_token(secret_name):
    if not secret_name:
        raise Exception("GitHub token secret name not provided")
    try:
        response = secrets_client.get_secret_value(SecretName=secret_name)
        return response['SecretString']
    except Exception as e:
        raise Exception(f"Failed to retrieve GitHub token from secret {secret_name}: {str(e)}")


def get_scan_result(bucket_name, scan_id):
    response = s3_client.get_object(
        Bucket=bucket_name,
        Key=f"scan-results/{scan_id}/result.json"
    )
    return json.loads(response['Body'].read().decode('utf-8'))


def extract_repo_name(repo_url):
    repo_url = repo_url.rstrip('/').replace('.git', '')
    if 'github.com/' in repo_url:
        return repo_url.split('github.com/')[-1]
    raise ValueError(f"Could not parse GitHub repo from URL: {repo_url}")


def apply_fix(repo_path, remediation):
    file_path = repo_path / remediation['file']
    if not file_path.exists():
        raise FileNotFoundError(f"File not found: {remediation['file']}")

    with open(file_path, 'r', encoding='utf-8') as f:
        lines = f.readlines()

    start_line = remediation['line'] - 1
    end_line = remediation.get('end_line', remediation['line']) - 1
    fixed_code = remediation['fixed_code']
    if not fixed_code.endswith('\n'):
        fixed_code += '\n'

    lines[start_line:end_line + 1] = [fixed_code]

    with open(file_path, 'w', encoding='utf-8') as f:
        f.writelines(lines)

    print(f"Applied fix to {remediation['file']}:{remediation['line']}")


def generate_pr_description(scan_data, scan_id):
    patch_plan = scan_data.get("patch_plan", [])
    description = f"""## üõ°Ô∏è Automated Security Patch Report (Scan ID: {scan_id})

This pull request was automatically generated following a security scan.
It includes AI-generated patches for the following vulnerabilities:

| Severity | Type | File |
|-----------|------|------|
"""

    if patch_plan:
        for p in patch_plan:
            description += f"| {p.get('severity', '').capitalize()} | {p.get('vulnerability', 'Unknown')} | {p.get('file', '')} |\n"
    else:
        description += "| ‚Äî | ‚Äî | ‚Äî |\n"

    description += """

---

‚úÖ **All fixes have been automatically applied and tested for syntax correctness.**  
‚ö†Ô∏è Please review before merging to ensure business logic remains intact.

_This PR was generated by AWS Dispatch Security Agent (Claude + Bedrock)._
"""
    return description
